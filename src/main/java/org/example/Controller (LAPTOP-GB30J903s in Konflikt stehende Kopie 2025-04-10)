//todo next: delete listener -> delete song from queue
// last today: message Craig, describe app and ask in what way he might be able to help. first think about metadata model storage because this is significant.
//todo after: implementation jaudiotagger, read metadata
// -store metadata in Map (file? archive?)
// -comprehend TableColumn method - TableRowCellFactory w/e?
// -apply metadata to TableColumns
// -choose a handful of relevant metadata to finish out the base player
//todo likely last: design and implement SQLite database for "caching" beyond runtime.
// -refine and enhance implementation: design efficiency and safety, call/update/synchronization
package org.example.musikplayer_doit.controller;
//test 1235
// import javafx.application.Platform;
import javafx.application.Platform;
import javafx.beans.value.ChangeListener;
import javafx.beans.value.ObservableValue;
import javafx.collections.FXCollections;
import javafx.collections.ObservableList;
import javafx.concurrent.Task;
import javafx.event.EventHandler;
import javafx.fxml.FXML;
import javafx.scene.Node;
import javafx.scene.control.*;
import javafx.scene.control.cell.PropertyValueFactory;
import javafx.scene.input.KeyCode;
import javafx.scene.input.KeyEvent;
import javafx.scene.input.MouseEvent;
import javafx.scene.input.ScrollEvent;
import javafx.scene.layout.BorderPane;
import javafx.scene.media.Media;
import javafx.scene.media.MediaPlayer;
import javafx.util.Callback;
import javafx.util.Duration;
import org.example.musikplayer_doit.model.Playlist;
import org.example.musikplayer_doit.model.Song;
import org.example.musikplayer_doit.services.ContextMenuService;

import org.example.musikplayer_doit.services.FolderScanTask;
import org.example.musikplayer_doit.services.TreeViewBuilderService;

import java.io.File;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.concurrent.ForkJoinPool;

//todo: user option to set root folder

public class Controller {

    MediaPlayer player;


    @FXML
    private TreeView<File> folderTreeView;
    @FXML
    private TableView<Song> centerTableView;
    @FXML
    private TableView<Song> playingTableView;
    @FXML
    private TableColumn<File, String> titleColumn; //TableColumn<S, T> S=Datentyp von TableView, T=Datentyp in Spalte
    @FXML
    private TableColumn<File, String> pathColumn;
    @FXML
    private TableColumn<File, String> lengthColumn;
    @FXML
    private TableColumn<Song, String> queueTitleColumn;
    @FXML
    private TableColumn<Song, String> queueLengthColumn;
    @FXML
    private ProgressBar progressBar;
    @FXML
    private Label barTimer;
    @FXML
    private Tooltip barTooltip;
    @FXML
    Slider volumeSlider;
    @FXML
    Button playButton;
    @FXML
    Label playButtonLabel;
    @FXML
    BorderPane borderPane;


    private Node previousFocus;
    private int loopCount;
    public Song selectedSong;
    public Song currentSong;
    ContextMenuService contextMenuService;
    TreeViewBuilderService treeViewBuilderService;




    public ObservableList<Song> centerList = FXCollections.observableArrayList();
    //public ObservableList<Song> queue = FXCollections.observableArrayList();
    Playlist queue;

//mostly done: initialize() abspecken (auslagern)


    public void initialize() {
        initializeTreeView();
        applyCellFactory();
        trackBorderPaneFocus();
        handleVolumeSlider();
        //MouseEventService mouseEventService;
        centerTableView.requestFocus();
        //barTimer.setText("00:00");
        volumeSlider.setMin(0);
        volumeSlider.setMax(1);
        volumeSlider.setValue(0.2);
        // Initialize the Playlist
        queue = new Playlist();

        // Set the items of the playingTableView to the Playlist's queue
        //centerTableViewClickOrKeyPressEventHandler();
        //playingTableViewClickOrKeyPressEventHandler();
        //private void centerTableViewClickOrKeyPressEventHandler();
        //private void playingTableViewClickOrKeyPressEventHandler();
        centerTableView.setOnMouseClicked(event -> {
            if (event.isAltDown()) {
                if (event.getClickCount() == 2) {
                    singlePlay();
                }
            } else if (event.isControlDown()) {
                if (event.getClickCount() == 2) {
                    addToQueue();
                }
            } else {
                if (event.getClickCount() == 2) {
                    handleEnterOrDoubleClickCenterTableView();
                }
            }
        });
        centerTableView.setOnKeyPressed(keyEvent -> {
            if (keyEvent.isAltDown()) {
                if (keyEvent.getCode() == KeyCode.ENTER) {
                    singlePlay();
                }
            } else if (keyEvent.isControlDown()) {
                if (keyEvent.getCode() == KeyCode.ENTER) {
                    addToQueue();
                }
            } else {
                if (keyEvent.getCode() == KeyCode.ENTER) {
                    handleEnterOrDoubleClickCenterTableView();
                }
            }
            if (keyEvent.getCode() == KeyCode.SPACE) {
                if (player != null) {
                    if (player.getStatus() == MediaPlayer.Status.PLAYING) {
                        System.out.println("(Spacebar) Playback paused from "+player.getStatus());
                        player.pause();
                    }

                    if (player.getStatus() == MediaPlayer.Status.PAUSED || player.getStatus() == MediaPlayer.Status.HALTED|| player.getStatus() == MediaPlayer.Status.STOPPED) {
                        System.out.println("(Spacebar) Playback resumed from "+player.getStatus());
                        player.play();
                    }
                }
            }
        });
        playingTableView.setOnMouseClicked(event -> {
            if (event.getClickCount() == 2) {
                handleEnterOrDoubleClickPlayingTableView();
            }
        });

        playingTableView.setOnKeyPressed(keyEvent -> {
            if (keyEvent.getCode() == KeyCode.ENTER) {
                handleEnterOrDoubleClickPlayingTableView();
            }

            if (keyEvent.getCode() == KeyCode.SPACE) {
                if (player != null) {
                    if (player.getStatus() == MediaPlayer.Status.PLAYING) {
                        System.out.println("(Spacebar) Playback paused from "+player.getStatus());
                        player.pause();
                    }

                    if (player.getStatus() == MediaPlayer.Status.PAUSED || player.getStatus() == MediaPlayer.Status.HALTED|| player.getStatus() == MediaPlayer.Status.STOPPED) {
                        System.out.println("(Spacebar) Playback resumed from "+player.getStatus());
                        player.play();
                    }
                }
            }
            playingTableView.setOnKeyPressed(new EventHandler<KeyEvent>() {
                @Override
                public void handle(KeyEvent keyEvent) {
                    if (keyEvent.getCode() == KeyCode.DELETE){
                        deleteSongFromQueue();
                    }
                }
            });
        });
        queueTitleColumn.setCellValueFactory(new PropertyValueFactory<>("title"));
        //queueLengthColumn.setCellValueFactory(new PropertyValueFactory<>("songLength"));
//        playingTableView.setOnMouseClicked(event -> {
//            if (event.getClickCount() == 2) {
//                handleDoubleClick(event);
//            }
//        });

//        Platform.runLater(new Runnable() {
//            @Override public void run() {
//                progressBar.setProgress(counter/1000000.0);
//            }
//
//        });

    }

    private void handleKeyPress(KeyEvent event){

    }



    // - - - - - - - - - - - - - - - - - - - - - TreeViewController - - - - - - - - - - - - - - - - - - - - - - - - -

    // Multithreading: https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ForkJoinPool.html
private long startTime;

    public void initializeTreeView(){
        folderTreeView.setMouseTransparent(true);
        folderTreeView.setOpacity(0.5);
        File rootFile = new File("D:/");
        TreeItem<File> rootItem = new TreeItem<>(rootFile);
        folderTreeView.setRoot(rootItem);

                // ForkJoinPool für parallele Verarbeitung
//                ForkJoinPool pool = new ForkJoinPool();
//                pool.invoke(new FolderScanTask(rootFile, rootItem));

        //Anonyme Klasse von Task wird erstellt und instanziiert
        Task<Void> task = new Task<>() {
            @Override
            protected Void call() {
                startTime = System.currentTimeMillis();
                createTree(rootFile, rootItem);
                return null;
            }
        };
        //Kurzschreibweise:
        //        Task<Void> task = new Task<>(() -> {
        //            createTree(rootFile, rootItem);
        //            return null;
        //        });
        task.setOnSucceeded(_ -> {
            long endTime = System.currentTimeMillis();
            long duration = endTime - startTime;
                System.out.println("Finished loading directories! \n-> Total processing time: "+duration/1000+" seconds.");
            folderTreeView.setMouseTransparent(false);
            folderTreeView.setOpacity(1);
            cleanup();
        });
        new Thread(task).start();
    }

    //loopCount als Instanzvariable deklariert verhindert (versehentliche) Überschreibung durch Methoden
    //Dies hat zu tun mit Object State.
    //Instanzvariablen sind deklariert auf Klassenebene. Initialisierung erfolgt mit Instanziierung der Klasse.
    //Sie bestehen während der gesamten Laufzeit des Objektes-
    //Methodenvariablen oder lokale Variablen auf Methodenebene
    //Sie werden bei Erstellung der Methode erstellt und nach Ausführung zerstört
    //Erstellung cleanup()-Methode für Garbage Collector, da Variable nie wieder relevant


    //TreeView::getExpandedItemCount() // folderTreeView.getExpandedItemCount()

    private void createTree(File file, TreeItem<File> parentItem) {
        File[] files = file.listFiles(File::isDirectory);
        if (files != null) {
            List<TreeItem<File>> batch = new ArrayList<>();
            for (var f : files) {
                //infer filetype <>
                loopCount += 1;
                System.out.println("Scanned: "+loopCount+" of x");
                TreeItem<File> item = new TreeItem<>(f);
                batch.add(item);
                createTree(f, item);
            }

            //Platform.runLater(() -> {
                parentItem.getChildren().addAll(batch);
                //folderTreeView.layout();
           // }); // Batch-Update
            //folderTreeView.setCellFactory(new Callback<TreeView<File>, TreeCell<File>>() {
        }
    }
//    private void createTree(File file, TreeItem<File> parentItem) {
//            File[] files = file.listFiles(File::isDirectory);
//
//            if (files != null && files.length > 0) {
//                int batchSize = 200;
//
//                // Process files in batches
//                for (int i = 0; i < files.length; i += batchSize) {
//                    int end = Math.min(i + batchSize, files.length); // Don't go out of bounds
//
//                    for (int j = i; j < end; j++) {
//                        File f = files[j];
//                        loopCount++;
//                        System.out.println("Scanned: " + loopCount + " of x");
//
//                        TreeItem<File> item = new TreeItem<>(f);
//                        parentItem.getChildren().add(item);
//
//                        // Recursive call — this will also process children in batches
//                        createTree(f, item);
//                    }
//
//                    // Optionally, insert a pause or yield control to avoid UI freezing
//                    // You could implement a background task and yield here if needed
//                }
//            }
//        }


    //    private void createTree(File file, TreeItem<File> parentItem) {
    //        File[] files = file.listFiles(File::isDirectory);
    //        if (files != null) {
    //            int batchSize = 100; // Adjust batch size as needed
    //            for (int i = 0; i < files.length; i += batchSize) {
    //                int end = Math.min(i + batchSize, files.length);
    //                for (int j = i; j < end; j++) {
    //                    var f = files[j];
    //                    TreeItem<File> item = new TreeItem<>(f);
    //                    parentItem.getChildren().add(item);
    //                    loopCount++;
    //                    System.out.println("Loops: " + loopCount);
    //                }
    //                // Optionally, add a delay or yield to allow UI updates
    //                try {
    //                    Thread.sleep(10); // Adjust delay as needed
    //                } catch (InterruptedException e) {
    //                    Thread.currentThread().interrupt();
    //                }
    //            }
    //        }
    //    }

//    private int getTotalItemCount(File[] files) {
//         totalLength = 1; // Count the root itself
//
//            for (var f : files) {
//                totalLength += 1;
//            }
//
//        return totalLength;
//    }

//    private int countTotalFolders(File[] files) {
//
//        int folderCount = 0;
//        if (files != null) {
//            folderCount += files.length;
//            for (var f : files) {
//                folderCount += f.length();
//            }
//        }
//        return folderCount;
//    }

//        int[] folderCount = new int[0];
//        if (files != null){
//            folderCount += files.length;
//            for (var f : files){
//                folderCount += countTotalFolders(f);
//            }
//        }
//        int totalFolderCount = 0;
//        for (var i : folderCount){
//            totalFolderCount += i;
//        }
//        return totalFolderCount;
//    }

    //done: TreeItems sollen nur nach Ordnern, nicht komplettem Pfad benannt sein.
    public void applyCellFactory() {
        //normal                                                                                       setCellFactory (...everything below
        folderTreeView.setCellFactory(new Callback<TreeView<File>, TreeCell<File>>() { // (functional interface)
            //Callback (P, R){R (output) call (P p(input));}
            // TreeView<File> is input, TreeCell<File> is output
            @Override
            public TreeCell<File> call(TreeView<File> treeView) { // call () {...
                return new TreeCell<>() {   //return new TreeCell<>{...
                    @Override
                    protected void updateItem(File item, boolean empty) { //protected void updateItem(File item, boolean empty) {...
                        super.updateItem(item, empty);

//                        if (empty || item == null) {
//                            setText(null);
//                        } else if (getTreeItem().getParent() == null) { //done: Check if getParent only displays root, and much improved code. Saved many thousands of unneeded iterations / checks
//                            setText("D:/");
//                        } else {
//                            setText(item.getName());
//                        }
                        // Even with mouseTransparent, rendering continues during:
                        //Platform.runLater(() -> parentItem.getChildren().addAll(batch));
                        // Multiple rapid runLater calls can queue overlapping renders
//    if (empty || item == null) {
//        setText(null);
//    } else {
//        TreeItem<File> currentItem = getTreeItem();
//        if (currentItem.getParent() == null) { // This condition is only checked once for the root node
//            setText("D:/");
//        } else {
//            setText(item.getName());
//
                        if (empty || item == null) {
                            setText(null); // Clear the cell if it's empty
                            setGraphic(null);
                        }
                        if (!empty && item != null){
                            if (getTreeItem().getParent() == null){
                                setText("D:/");
                            } else {
                                setText(item.getName());
                            }
                        }
                    }
                };
            }
        });
    }

    //Cellfactory customizes rendering of cells in a ListView, TableView, TreeView

//lambda
//        folderTreeView.setCellFactory(treeView -> new TreeCell<>() {
//            @Override
//            protected void updateItem(File item, boolean empty) {
//                super.updateItem(item, empty);
//                if (empty || item == null) {
//                    setText(null);
//                } else {
//                    setText(item.getName());
//                }
//            }
//        });




// - - - - - - - - - - - Initialisierung TreeView, Task Erstellung - - - - - - - - - - - - - - -

// _  ist event - Langschreibweise:
//        task.setOnSucceeded(new EventHandler<WorkerStateEvent>() {
//            @Override
//            public void handle(WorkerStateEvent workerStateEvent) {
//                System.out.println("Finished loading directories no Lambda!");
//            }
//        });

            /*
             * public returnType:TreeCell<Type> call(TreeView<Type> parameterName) {
             * return new TreeCell<>() { anonymous class
             * @Override from TreeCell superclass
             * protected void updateItem(Type item, boolean empty) { protected accessible package-wide and subclasses
             * super.updateItem(item, empty); call superclass method and pass new parameters
             *
             * */
//        public | TreeCell<File> | call | (TreeView<File> treeView) | { // beginning of code block
//        // Create and return a new TreeCell with a custom updateItem method
//        return new TreeCell<>() {
//            @Override
//            protected void updateItem(File item, boolean empty) {
//                // Call the superclass's updateItem method
//                super.updateItem(item, empty);
//                // Set the text of the cell based on the item
//                if (empty || item == null) {
//                    setText(null);
//                } else {
//                    setText(item.getName());
//                }
//            }
//        };
//} // end of code block





    /*
    public void initialize() {
//        TreeItem<File> rootItem = new TreeItem<File> "C://";
//        folderTreeView.setRoot(rootItem);

        File rootFile = new File("D:\\");
        TreeItem<File> rootItem = new TreeItem<>(rootFile);
        folderTreeView.setRoot(rootItem);

        new Thread(() -> createTree(rootFile, rootItem)).start();
        System.out.println("Finished loading directories!");
    }
    */
        /*
        File[] roots = File.listRoots();
        TreeItem<File> rootItem = new TreeItem<>(new File("My Computer"));
        folderTreeView.setRoot(rootItem);

        if (roots != null){
            for (var r : roots){
                TreeItem<File> item = new TreeItem<>(r);
                rootItem.getChildren().add(item);
                new Thread (() -> createTree(r, rootItem)).start();
            }
        }
    }
         */
// - - - - - - - - - - - - - - - - - - - - - - Slider and ProgressBar - - - - - - - - - - - - - - - - - - - - - -
    @FXML
    private void updateProgressBar () {
//        Button button = new Button("test");
//        button.setTooltip();
    }


    private void trackBorderPaneFocus(){
        borderPane.sceneProperty().addListener((observable, oldScene, newScene) -> {
            if (newScene != null) {
                newScene.focusOwnerProperty().addListener((obs, oldFocus, newFocus) -> {
                    if (newFocus != volumeSlider) { // Speichere den Fokus, wenn es nicht der Slider ist
                        previousFocus = newFocus;
                    }
                });
            }
        });
    }

    //done: Volume Slider responsiv machen. Problem: Scheint nur zwischen 0 und 100 zu wechseln. Lösung: MediaPlayer hat Volume zwischen 0 - 1, Slider 0 - 100.
    //volumeSlider Error Handling mit Null Check
    //todo: Volume Slider stylen ein Stück weit wie ProgressBar.
    //todo: sicherstellen dass volumeSlider und playerVolume stets synchronisiert sind.
    @FXML
    private void handleVolumeSlider () {
        //volumeSlider.minProperty().setValue(0);
        //volumeSlider.maxProperty().setValue(100);

//        volumeSlider.valueProperty().addListener((observable, oldValue, newValue -> {
//                    System.out.println("Initial volume level: "+volumeSlider.getValue());
//            double volumeSet = volumeSlider.setValue(newValue.doubleValue());
//            player.volumeProperty().setValue(volumeSet);
//                    System.out.println("New volume level: "+volumeSet);
        //}));

        if (player == null){
            System.out.println("No player instance found, cannot set volume. Will be updated on playback within 0.05 margin of error.");
        }
        volumeSlider.addEventFilter(ScrollEvent.SCROLL, scrollEvent -> {
            double delta = scrollEvent.getDeltaY() > 0 ? 0.05 : -0.05;
//                 double delta = scrollEvent.getDeltaY();
//                 if (delta > 0) {
//                     delta = 0.05;
//                 } else {
//                     delta = -0.05;
//                 }
            double previousVolume = volumeSlider.getValue();
            double newVolume = previousVolume+delta;
            Platform.runLater(() -> {
                volumeSlider.setValue(newVolume);
            });
            System.out.println("New Volume set by mouse wheel to: "+newVolume);

        });
//        volumeSlider.addEventFilter(MouseEvent.MOUSE_PRESSED, event -> {
//
//        });
        //todo: idealerweise gar nicht erst Fokus auf VolumeSlider erlauben, und all dies sparen
            volumeSlider.addEventFilter(MouseEvent.MOUSE_RELEASED, event -> {
            if (previousFocus != null) {
                previousFocus.requestFocus(); // Setze den Fokus zurück
            }

        });

        volumeSlider.valueProperty().addListener(new ChangeListener<Number>() {
            @Override
            public void changed(ObservableValue<? extends Number> observableValue, Number oldNunmber, Number newNumber) {
                System.out.println("initial volume level: " + volumeSlider.getValue());
                double volumeSet = newNumber.doubleValue();



                if (player != null){
                    System.out.println("player volume: " + player.getVolume());
                    System.out.println("set volume level to: " + volumeSet);
                    Platform.runLater(() -> {
                        player.setVolume(volumeSet);
                    });
                }
            }

        });




    }

    private void setProgressBar() {
        player.currentTimeProperty().addListener((observable, oldValue, newValue) -> {
            double offset =  0.03; // 3%
            double currentTime = newValue.toSeconds();
            double totalDuration = player.getTotalDuration().toSeconds();
            //double progress = currentTime / totalDuration;
            double progress = (currentTime / totalDuration) * (1 - offset) + offset;

            progressBar.setProgress(progress);

//hours erstellt 1 3600stel, zählt im Laufe einer Stunde hoch bis 3600
//minutes und seconds arbeiten mit Modulo, um Breakpoints zu gewährleisten.
// Bei genau 60 Sekunden stehen seconds auf 0 und es ist stattdessen 1 minute.
// Ebenso ist es bei genau 3600 Sekunden (60 Minuten) eine Stunde, und Minuten stehen auf 0
            int hours = (int) currentTime / 3600;
            int minutes = (int) (currentTime%3600) / 60;
            int seconds = (int) currentTime%60;


            //cool shorthand for an if-else statement. condition ?ifTrue :ifFalse
            String timeString = (hours > 0)
//String.format method: % specifies start of format; d decimal integer.
//02: 0 means to pad with leading zeroes if necessary. 2 is the width of the number
                    ? String.format("%d:%02d:%02d", hours, minutes, seconds)
                    : String.format("%02d:%02d", minutes, seconds);
            Platform.runLater(() -> {
                barTimer.setText(timeString);
            });
            //barTimer.setText(String.format("%.00f", newValue.toSeconds()));

        });
    }

// - - - - - - - - - - - - - - - - - - - - - PlaybackController - - - - - - - - - - - - - - - - - - - - - - - - -

    private void playSelection() {
        if (player != null){
            player.stop();
            player.dispose();
            System.out.println("Player instance detected and disposed, create new instance...");
        }
//        Platform.runLater(() -> {...});
        Media newPlayback = songToMedia(selectedSong);
        player = new MediaPlayer(newPlayback);
        System.out.println("Playing after double click or enter press: "+newPlayback+", which is the same as "+selectedSong.getTitle());

//        Task<Void> task = new Task<>() {
//                @Override
//                protected Void call() {
//                    initiatePlay();
//                    return null;
//                }
//            };
//            task.setOnSucceeded(_ -> player.play();)
//            new Thread(task).start();


        initiatePlay();
        player.play();
    }
    private void initiatePlay () {
        setProgressBar();
        player.setVolume(volumeSlider.getValue());
        transformPlayButton();
        setCurrentSong();
        styleCurrentSong();
        playerBehavior();
    }

    //done: Styling funktioniert, aber nicht (nun) richtig
    private void styleCurrentSong(){
//       playingTableView.setRowFactory(rv -> new TableRow<> () {
//           @Override
//           protected void updateItem(Song item, boolean empty) {
//               super.updateItem(item, empty);
//               if (item != null && item.equals(currentSong)) {
//                   setStyle("-fx-font-weight: bold;");
//               } else {
//                   setStyle(""); // Reset style for other rows
//               }
//           }
//       });
        playingTableView.setRowFactory(new Callback<TableView<Song>, TableRow<Song>>() {
            @Override
            public TableRow<Song> call(TableView<Song> tableView) {
                return new TableRow<>() {
                    @Override
                    protected void updateItem(Song item, boolean empty) {
                        super.updateItem(item, empty);
                        if (item != null && item.equals(currentSong)) {
                            setStyle("-fx-font-weight: bold;");
                        } else {
                            setStyle(""); // Reset style for other rows
                        }
                    }
                };
            }
        });
        playingTableView.setRowFactory(new Callback<TableView<Song>, TableRow<Song>>() {
            @Override
            public TableRow<Song> call(TableView<Song> songTableView) {
                return null;
            }
        });

        centerTableView.setRowFactory(tv -> new TableRow<>() {
            @Override
            protected void updateItem(Song item, boolean empty) {
                super.updateItem(item, empty);
                if (item != null && item.equals(currentSong)) {
                    setStyle("-fx-font-weight: bold;");
                } else {
                    setStyle(""); // Reset style for other rows
                }
            }
        });

    }

    //done: play method respond to focus instead of selection
    //done: play method respond to double click and enter press on selection

    private void playerBehavior() {
        //player.setOnEndOfMedia(this::playNextOrStop);
//        player.setOnEndOfMedia(() -> {
//            playNextOrStop();
//                });
        if (player == null){
            return;
        }
        player.setOnEndOfMedia(new Runnable() {
            @Override
            public void run() {
                System.out.println("endOfMedia triggered by method playerBehavior();");
                progressBar.setProgress(0);
                playNextOrStop();
            }
        });
    }
    //mostly done: clickPlay auslagern / abspecken
    //done: Timer updaten
    //done: Timer formatieren
    //todo: ProgressBar anklickbar machen und Lied zur Stelle vorspulen
    //todo: kleine Popups bei Mouseover: ProgressBar Minute:Sekunde, über TableColumn gesamter Inhalt, ebenso über TreeItem.

    ///A Scene in JavaFX represents the content of a stage (window). It is a container for all the visual elements
    //done: morph play symbol into pause symbol during playback
    private void transformPlayButton(){
        if (player == null){
            return;

        }
        player.statusProperty().addListener((observable, oldStatus, newStatus) -> {
            if (newStatus == MediaPlayer.Status.PLAYING){
                playButtonLabel.setText("⏸"); // \u23F8
            }
            if (newStatus == MediaPlayer.Status.STOPPED || newStatus == MediaPlayer.Status.PAUSED){
                playButtonLabel.setText("▶"); // \u25B6
            }
        });

        // \u25B6 for play (▶) and \u23F8 for pause (⏸).
    }

    private void handleEnterOrDoubleClickPlayingTableView() {
        if (player != null){
            player.stop();
            player.dispose();
        }
        selectedSong = playingTableView.getSelectionModel().getSelectedItem();
        Media assignPlay = songToMedia(selectedSong);
        player = new MediaPlayer(assignPlay);
        playSelection();
        initiatePlay();
    }

    private void handleEnterOrDoubleClickCenterTableView() {
        queue.clearQueue();
        ObservableList<Song> newQueue = FXCollections.observableArrayList(centerTableView.getItems());
        queue.setQueue(newQueue);
        playingTableView.setItems(queue.getQueue());
        for (var song : queue.getQueue()){

            System.out.println("Added: "+song.getTitle());
        }
        selectedSong = centerTableView.getSelectionModel().getSelectedItem();
        playSelection();
        //        if (player == null||player.getStatus() == MediaPlayer.Status.STOPPED) {
//
//            player = new MediaPlayer(new Media(new File(selectedSong.getPath()).toURI().toString()));
//            if (volumeSlider.getValue() != player.getVolume()){
//                player.setVolume(volumeSlider.getValue());
//            }
//
//            if(selectedSong != null) {
//                player.play();
//                queue.addSong(selectedSong);
//                System.out.println("Playing: " + selectedSong.getTitle());
//            }
//        } else {
//            MediaPlayer.Status status = player.getStatus();
//            if (status == MediaPlayer.Status.PAUSED) {
//                player.play();
//                System.out.println("Resuming playback");
//            } else if (status == MediaPlayer.Status.PLAYING) {
//                player.pause();
//                System.out.println("Paused playback");
//            }
//        }
//        setProgressBar();
    }

//player = new MediaPlayer(new Media(new File (selectedSong.getPath()).toURI().toString()));
//String uriString = new File("D:\\Musikmainaug2019\\Aku no Hana\\\uD83D\uDC40 Zankyou no Hana.mp3").toURI().toString();
    private void singlePlay(){
        if (player != null){
            player.stop();
            player.dispose();
            System.out.println("Disposed player instance for singlePlayback.");
        }
        selectedSong = centerTableView.getSelectionModel().getSelectedItem();
        queue.clearQueue();
        queue.addSong(selectedSong);
        playingTableView.setItems(queue.getQueue());
        Media assignSinglePlay = songToMedia(selectedSong);
        player = new MediaPlayer(assignSinglePlay);
        playSelection();
        initiatePlay();
        //todo: allow multiple selection during ctrl-click, probably redesign method with array for selection
    }
    private void addToQueue(){
        selectedSong = centerTableView.getSelectionModel().getSelectedItem();
        queue.addSong(selectedSong);
    }
    private void deleteSongFromQueue(){
        selectedSong = playingTableView.getSelectionModel().getSelectedItem();
        queue.removeSong(selectedSong);
    }

    @FXML
    private void clickPlay() {
        if (queue == null) {
            System.out.println("No song in Playlist.");
            return;
        }
        if (player == null){
            System.out.println("No player found.");
            return;
        }
        if (player.getStatus() == MediaPlayer.Status.PLAYING){
            player.pause();
            System.out.println("Paused playback of "+currentSong);
        } else {
            player.play();
            System.out.println("Playing: "+currentSong);
        }

        //    return new Media(new File(song.getPath()).toURI().toString());
//
//        ObservableList<Song> currentQueue = queue.getQueue();
//        if (player == null ||player.getStatus() == MediaPlayer.Status.STOPPED) {
//            var media = songToMedia(currentSong);
//            player = new MediaPlayer(media);
//        }
//        //player.getStatus() == MediaPlayer.Status.PAUSED||player.getStatus() == MediaPlayer.Status.STALLED
//        player.play();
//        initiatePlay();
    }

    private void handleDoubleClick (MouseEvent event){

//        for (var i : list){
//            queue.getQueue().addAll(i);
//        }
    }


    //todo: idee: während drag auf ProgressBar per Tastendruck (oder drag out of bounds?) Tonspur anzeigen lassen

    private void handlePlayback () {
        //handleVolumeSlider();

    }


//Idee für Parser-Methode: Source und Path ineinander umwandeln. Path hat \ und Leerzeichen. Source hat / und %20 statt Leerzeichen
    //So wäre Media.getSource zu Song.getPath umwandelbar.

    private String parseSourceToPath(String mediaSource){

        String sourceToPath = mediaSource.replace("%20", " ");
        sourceToPath = sourceToPath.replace("file:/", "");
        sourceToPath = sourceToPath.replace("/", "\\");

                return sourceToPath;
    }

    private Song findSongByPath(ObservableList<Song> songList, String path){
        for (var s : songList){
            if (s.getPath().equals(path)){
                System.out.println("return statement of findSongByPath(): "+s);

                return s;
            }
        }
        return null;
    }
//todo: test and fix with headphones
    private void playPrevious(){
        if (player == null) {
            System.out.println("No player instance found.");
            return;
        }
        ObservableList<Song> currentQueue = queue.getQueue();
        int currentSongIndex = currentQueue.indexOf(currentSong);
        Song previousSong;
        if (currentSongIndex == currentQueue.size()-1){
            player.seek(Duration.ZERO);
            System.out.println("No song before the current song in queue, playback set to 0 and continuing.");
        } else {
            previousSong = currentQueue.get(currentSongIndex-1);
            System.out.println("Setting previous song: "+previousSong);
        }
    }

    private void setCurrentSong(){
        System.out.println("Method called: setCurrentSong (by initiatePlay())");
        ObservableList<Song> currentQueue = queue.getQueue();
        String currentMediaSource = player.getMedia().getSource();
        System.out.println("currentMediaSource: "+currentMediaSource);
        String sourceToPath = parseSourceToPath(currentMediaSource);
        System.out.println("sourceToPath: "+sourceToPath);
        currentSong = findSongByPath(currentQueue, sourceToPath);
        System.err.println("Current song as determined by setCurrentSong: "+sourceToPath);
    }

    //done: potentiell auslagern in "private Song determineCurrentSong(ObservableList<Song> list)?"
    private void playNextOrStop() {
        System.out.println("Method call: playNextOrStop.");
        if (player == null) {
            System.out.println("No player found.");
            return;
        }

        ObservableList<Song> currentQueue = queue.getQueue();
        int currentSongIndex = currentQueue.indexOf(currentSong);
        Song nextSong;
        if (currentSongIndex == currentQueue.size() - 1) {
            player.stop();
            System.out.println("No more songs in current queue, playback stopped.");
            return;
        } else {
            nextSong = currentQueue.get(currentSongIndex + 1);
            System.out.println("Setting next song: " + nextSong);
        }
        if (nextSong != null) {
            if (currentSong != null) {
                player.stop();
                Media nextPlay = songToMedia(nextSong);
                player = new MediaPlayer(nextPlay);
                player.play();
                initiatePlay();
                System.out.println("Playing next song in playlist: " + nextPlay.getSource());
            }
        }

    }

    private Media songToMedia(Song song){
        return new Media(new File(song.getPath()).toURI().toString());
    }
//    private Song mediaToSong(Media media){
//        return new Media(new File(song.getPath()).toURI().toString());
//    }



    @FXML
    public void clickStop() {
        if (player != null) {
            player.stop();
            System.out.println("Stopped playback");
        }
    }


    //todo: use/create update playlist methods
    //done: enable skipping to parts of playlist for playback
    //partially done: required steps: instantiate ObservableList in method constructor. Instantiate Playlist in initialize method. update variable names and call Playlist methods.
    @FXML
    private void clickPrevious(){
        playPrevious();

    }

    @FXML
    private void clickNext(){
        playNextOrStop();
    }

    //todo: make autoplay PlayList default behavior,
    // create button and method for "stop after current track", which gets reset after playback stop
    // optionally configurable to not turn off on playback end.

    //todo: set focus on Playlist on click

    //todo: make TableView and Queue respond to keyboard input.
    // Enter: clearList and add entire folder to queue and play // just play.
    // alt+Enter: clearList and add selected song to queue
    // ctrl+Enter: add selected song to queue
    // Delete: Delete file (ask permission) // remove from list.

    //todo: Set new focus on arrow up/down.

    //todo: add further playback altering methods and buttons:
    // randomize playback
    // repeat playback
    // sleep timer
    // potentially advanced functions such as transpose, playback speed, equalizer
    //todo: drag & drop in queue


    // - - - - - - - - - - - - - - - - - - - - - TreeViewSelectionController - - - - - - - - - - - - - - - - - - - - - - - - -
//done: Nach mp3 Dateien filtern, möglichst vor dem ersten Ladeprozess
//done: Dateipfade im TreeView auf Ordnernamen reduzieren Cellfactory?
//done: Dateipfade in Titelspalte auf Dateinamen reduzieren Cellfactory? Cut/Trim Methode?


    //todo: besseres mouse handling für TreeView, idee:
    //public void initializeTreeView() {
    //    File rootFile = new File("D:/");
    //    TreeItem<File> rootItem = new TreeItem<>(rootFile);
    //    folderTreeView.setRoot(rootItem);
    //
    //    // Add an event filter to handle mouse clicks on the expand/collapse arrows
    //    folderTreeView.addEventFilter(MouseEvent.MOUSE_PRESSED, event -> {
    //        Node node = event.getPickResult().getIntersectedNode();
    //        if (node instanceof TreeView || (node != null && node.getStyleClass().contains("tree-disclosure-node"))) {
    //            event.consume(); // Prevent the event from being processed further
    //        }
    //    });
    //
    //    Task<Void> task = new Task<>() {
    //        @Override
    //        protected Void call() {
    //            createTree(rootFile, rootItem);
    //            return null;
    //        }
    //    };
    //    task.setOnSucceeded(_ -> System.out.println("Finished loading directories!"));
    //    new Thread(task).start();
    //}

    @FXML
    private void selectTreeItem(MouseEvent event) {

        // Determine if the click was on a TreeCell
        Node clickedNode = event.getPickResult().getIntersectedNode();
        while (clickedNode != null && !(clickedNode instanceof TreeCell<?>)) {
            clickedNode = clickedNode.getParent();
        }

        // If no TreeCell was found, clear the selection and return.
        if (clickedNode == null) {
            folderTreeView.getSelectionModel().clearSelection();
            // Optionally, clear the TableView as well.
            centerList.clear();
            centerTableView.setItems(centerList);
            return;
        }

        // At this point, a valid TreeCell was clicked.
        TreeItem<File> item = folderTreeView.getSelectionModel().getSelectedItem();

        // Clear previous list before loading new items
        centerList.clear();

        if (item != null) {
            File data = item.getValue();
            System.out.println("Selected: " + data);

            if (data.isDirectory()) {
                // List only .mp3 files in the directory.
                File[] files = data.listFiles((_, str) -> str.toLowerCase().endsWith(".mp3"));
                if (files != null) {
                    for (File f : files) {
                        // Assume Song has a constructor that accepts the file path.
                        Song song = new Song(f.getAbsolutePath(), null);
                        centerList.add(song);
                    }
                }
            } else {
                System.out.println("Not a directory");
            }
        } else {
            System.out.println("Invalid selection");
        }

        // Update the TableView with the new list.
        centerTableView.setItems(centerList);
        titleColumn.setCellValueFactory(new PropertyValueFactory<>("title"));
        pathColumn.setCellValueFactory(new PropertyValueFactory<>("path"));
    }



    // - - - - - - - - - - - - - - - - - - - - - TableViewSelectionController - - - - - - - - - - - - - - - - - - - - - - - - -

    //TreeItem<File> item = folderTreeView.getSelectionModel().getSelectedItem();


    // Song song = new Song(f.getAbsolutePath());
//                        centerList.add(song);2

    private void hoverTooltip() {

//        Duration delayDuration = Duration.millis(10);
//        barTooltip.setShowDelay(delayDuration);
//
//        barTooltip.setText("Beispiel");

    }

    //@FXML
    //private void selectTableItem(MouseEvent event) {
    //    Node clickedNode = event.getPickResult().getIntersectedNode();
    //    while (clickedNode != null && !(clickedNode instanceof TableRow<?>)) {
    //        clickedNode = clickedNode.getParent();
    //    }
    //
    //    // If no TableRow was found, or if the found row is empty, clear the selection and return.
    //    if (clickedNode == null || ((TableRow<?>) clickedNode).isEmpty()) {
    //        centerTableView.getSelectionModel().clearSelection();
    //        return;
    //    }
    //
    //    // At this point, a valid TableRow with a Song object was clicked.
    //    Song song = centerTableView.getSelectionModel().getSelectedItem();
    //    if (song != null) {
    //        System.out.println("Selected: " + song.getTitle());
    //        selectedSong = song;
    //        queue.add(song);
    //        playingTableView.setItems(queue);
    //        queueTitleColumn.setCellValueFactory(new PropertyValueFactory<>("title"));
    //    }
    //}


    //Scheduling: When Platform.runLater is called, it schedules the Runnable to be executed on the JavaFX Application Thread. This is the thread responsible for handling all JavaFX UI updates.
    //Execution: The JavaFX runtime maintains a queue of tasks to be executed on the JavaFX Application Thread. The Runnable provided to Platform.runLater is added to this queue.
    //Thread Safety: By ensuring that the Runnable is executed on the JavaFX Application Thread, Platform.runLater guarantees that any UI updates within the run method are performed in a thread-safe manner, avoiding concurrency issues.

    @FXML
    private void selectTableItem(MouseEvent event) {
        //actually not needed. Check if there is reason to keep it.
        //can check Platform.isFxApplicationThread(). If true, is part of JavaFX main thread, and can ignore runLater.
        //if false, platform.runlater makes code run on the main JavafX thread and enables GUI updates.
//        Platform.runLater(new Runnable() {
//            @Override
//            public void run() {
//...
//}});
                Node clickedNode = event.getPickResult().getIntersectedNode();
                while (clickedNode != null && !(clickedNode instanceof TableRow<?>)) {
                    clickedNode = clickedNode.getParent();
                }

                // If no TableRow was found, or if the found row is empty, clear the selection and return.
                if (clickedNode == null || ((TableRow<?>) clickedNode).isEmpty()) {
                    centerTableView.getSelectionModel().clearSelection();
                    return;
                }

                // At this point, a valid TableRow with a Song object was clicked.
                if (centerTableView.getSelectionModel().getSelectedIndex() > -1) {
                    int index = centerTableView.getSelectionModel().getSelectedIndex();
                    Song clickedItem = centerTableView.getSelectionModel().getSelectedItem();
                    String content = clickedItem.toString();

                    centerTableView.requestFocus();
                    boolean centerIsFocused = centerTableView.isFocused();

                    System.out.println("centerTableView is focused: "+centerIsFocused);



                    System.out.println();
                    centerTableView.getSelectionModel().select(index);
                    centerTableView.getFocusModel().focus(index);
                    System.out.println("focused Index " + index + " in centerTableView");
                }

                //call handleCenterSelectionChange



                Song song = centerTableView.getSelectionModel().getSelectedItem();
                if (song != null) {
                    System.out.println("Selected: " + song.getTitle());
                    if (selectedSong != null){
                        selectedSong = null;
                    }
                    selectedSong = centerTableView.getSelectionModel().getSelectedItem();
                    //todo: review
                    playingTableView.setItems(queue.getQueue());
                    queueTitleColumn.setCellValueFactory(new PropertyValueFactory<>("title"));
                }

    }
    @FXML
    private void showCenterContextMenu(MouseEvent event) {
        contextMenuService.displayContextMenu(event);
        centerTableView.setOnContextMenuRequested(e -> {
            ContextMenu contextmenu = new ContextMenu();
        });


        //e ->
        //.show(e.getScreenX(), e.getScreenY()));
    }

    private void handleCenterSelectionChange() {
        int selectedIndex = centerTableView.getSelectionModel().getSelectedIndex();
        if (selectedIndex != -1) {
            // Update focus to the selected index
            centerTableView.getFocusModel().focus(selectedIndex);
            System.out.println("Selection changed. Current index: " + selectedIndex);
            // Additional logic, like updating other UI components, can go here.
        }
    }

    private void cleanup(){
        loopCount = 0;
        startTime = 0;
    }


//            TableRow<?> row = null;
//
//            // Traverse up the node hierarchy to find the TableRow
//            while (clickedNode != null) {
//                if (clickedNode instanceof TableRow) {
//                    row = (TableRow<?>) clickedNode;
//                    System.out.println(((TableRow<?>) clickedNode).getItem()+"clickedNode");
//                    System.out.println(row.getItem()+"row");
//                    break; // Exit the loop once a TableRow is found
//
//                }
//                clickedNode = clickedNode.getParent(); // Move to the parent node
//            }
//
//            // If no TableRow was found, or if the found row is empty, clear the selection
//            if (row == null || row.getItem() == null) {
//                centerTableView.getSelectionModel().clearSelection();
//            }
//            return;




//alternativ erldigt: Adapt cellfactory for TableView and ObservableList vs. TreeView and TreeItems via Konstruktor selbst getName
            /*
                folderTreeView.setCellFactory(new Callback<TreeView<File>, TreeCell<File>>() { //Callback<>() ((functional interface)) {...
        @Override
        public TreeCell<File> call(TreeView<File> treeView) { //public TreeCell<File> call (TreeView<File> treeView) {...
            return new TreeCell<>() {   //return new TreeCell<>{...
                @Override
                protected void updateItem(File item, boolean empty) { //protected void updateItem(File item, boolean empty) {...
                    super.updateItem(item, empty);
                    if (empty || item == null) {
                        setText(null);
                    } else if (getTreeItem().getParent() == null) {
                        setText("D:/");
                    } else {
                        setText(item.getName());
                    }
                }
            };
        }
    });
            */


//            loadFilesFromPath(data);
//            centerTableView.setItems(centerList);
//            titleColumn.getTableView();


//    public ArrayList <Song> createCenterView () {
//        ArrayList <Song> asd;
//        return asd;
//    }


//    private void loadFilesFromPath(File folder){
//        if (folder != null && folder.isDirectory()){
//            File[] files = folder.listFiles((dir, name) -> name.toLowerCase().endsWith(".mp3"));
//            if (files != null) {
//                centerList.addAll(files);
//            }
//        }


    @FXML
    private void handleRefresh() {
        initialize();
    }
}

//    private ArrayList<Song> filesToTableView(ArrayList<File> file){
//
//    }


//            File[] files = data.listFiles((dir, name) -> name.toLowerCase().endsWith(".mp3"));
//            if (files != null) {
//                centerList.addAll(files);
//            }
//            centerTableView.setItems(centerList);
//            titleColumn.getTableView();









//    private void loadView () {
//
//
//
//    }


//fxcollections.observablearralist



/*
package org.example.musikplayer_doit.controller;

import javafx.collections.ObservableList;
import javafx.concurrent.Task;
import javafx.fxml.FXML;
import javafx.fxml.Initializable;
import javafx.scene.control.*;
import javafx.scene.media.Media;
import javafx.scene.media.MediaPlayer;
import javafx.stage.FileChooser;
import javafx.util.Callback;

import java.io.File;
import java.net.URL;
import java.util.ArrayList;
import java.util.List;
import java.util.ResourceBundle;
import java.util.concurrent.*;

//ToDo: Unverständlichen Code entfernen und schrittweise rekonstruieren.


public class Controller implements Initializable {

MediaPlayer player;

@FXML
private TreeView<File> folderTreeView;
@FXML
private TableView<File> centerTableView;
@FXML
private TableView<File> listTableView;
@FXML
TableColumn<File, String> titleColumn; //TableColumn<S, T> S=Datentyp von TableView, T=Datentyp in Spalte

private ExecutorService executorService;

    @FXML
    public void clickPlay() {
        if (player == null) {
            String uriString = new File("D:\\Musikmainaug2019\\Aku no Hana\\\uD83D\uDC40 Zankyou no Hana.mp3").toURI().toString();
            player = new MediaPlayer(new Media(uriString));
            player.play();
            System.out.println("Playing: " + uriString);
        } else {
            MediaPlayer.Status status = player.getStatus();
            if (status == MediaPlayer.Status.PAUSED || status == MediaPlayer.Status.STOPPED) {
                player.play();
                System.out.println("Resuming playback");
            } else if (status == MediaPlayer.Status.PLAYING) {
                player.pause();
                System.out.println("Paused playback");
            }
        }
    }

    @FXML
    public void clickStop() {
        if (player != null) {
            player.stop();
            System.out.println("Stopped playback");
        }
    }

    // FileTreeCellFactory

    // Multithreading: https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ForkJoinPool.html
    @Override
    public void initialize(URL url, ResourceBundle resourceBundle) {
        File rootFile = new File("My Computer");
        TreeItem<File> rootItem = new TreeItem<>(rootFile);
        folderTreeView.setRoot(rootItem);

        Task<Void> task = new Task<>() {
            @Override
            protected Void call() {
                ForkJoinPool pool = new ForkJoinPool();
                pool.invoke(new CreateTreeTask(rootFile, rootItem));
                return null;
            }
        };

        task.setOnSucceeded(event -> System.out.println("Tree creation completed."));
        task.setOnFailed(event -> System.err.println("Tree creation failed: " + task.getException()));

        new Thread(task).start();
    }

    private static class CreateTreeTask extends RecursiveAction {
        private final File file;
        private final TreeItem<File> parentItem;

        public CreateTreeTask(File file, TreeItem<File> parentItem) {
            this.file = file;
            this.parentItem = parentItem;
        }

        @Override
        protected void compute() {
            File[] files = file.listFiles(File::isDirectory);
            if (files != null) {
                for (var f : files) {
                    TreeItem<File> item = new TreeItem<>(f);
                    parentItem.getChildren().add(item);
                    CreateTreeTask task = new CreateTreeTask(f, item);
                    task.fork();
                }
            }
        }
    }
}




        /*

    @FXML
    private void selectItem () {

    }

    private void loadView () {



    }


//fxcollections.observablearralist

}

*/

/*
Singleton Pattern for VolumeSlider AI suggestion:
public class MediaPlayerSingleton {
    private static MediaPlayer instance;

    private MediaPlayerSingleton() {
        // Private constructor to prevent instantiation
    }

    public static synchronized MediaPlayer getInstance() {
        if (instance == null) {
            instance = new MediaPlayer();
            instance.setVolume(0.5); // Set default volume
            instance.setOnReady(() -> {
                // Additional initialization if needed
            });
        }
        return instance;
    }
}
public class Controller {
    private MediaPlayer player;

    public Controller() {
        this.player = MediaPlayerSingleton.getInstance();
    }

    public void handleVolumeSlider(double volume) {
        if (player != null) {
            player.setVolume(volume / 100.0); // Assuming the slider value is between 0 and 100
        }
    }
}
*/